

import os
import re
import sys
from collections import OrderedDict

processed_files = OrderedDict()

def get_full_path(path, base_dir):
    """Constructs the full path for a LaTeX file, adding .tex if missing."""
    if not path.endswith('.tex'):
        path += '.tex'
    return os.path.abspath(os.path.join(base_dir, path))

def process_file(file_path, output_file, base_dir, start_dir):
    """
    Recursively processes a LaTeX file, replacing \input, \include, and \import
    commands with the content of the specified files.
    """
    abs_path = get_full_path(file_path, base_dir)

    if abs_path in processed_files:
        print(f"-> Skipping already processed file: {os.path.basename(file_path)}")
        return

    try:
        with open(abs_path, 'r', encoding='utf-8') as f_in:
            print(f"Processing: {abs_path}")
            processed_files[abs_path] = True
            
            current_file_dir = os.path.dirname(abs_path)
            
            output_file.write(f"\n% --- Start of content from {os.path.relpath(abs_path, start_dir)} ---\n\n")

            for line in f_in:
                # Match \import{path}{file}
                import_match = re.search(r'\\import\{([^}]+)\}\{([^}]+)\}', line)
                # Match \input{file} or \include{file}
                include_match = re.search(r'\\(input|include)\{([^}]+)\}', line)

                if import_match:
                    import_dir = import_match.group(1)
                    import_file = import_match.group(2)
                    # \import paths are relative to the main file's directory (start_dir)
                    new_base_dir = os.path.join(start_dir, import_dir)
                    process_file(import_file, output_file, new_base_dir, start_dir)
                elif include_match:
                    included_file = include_match.group(2)
                    # \input and \include paths are relative to the current file's directory
                    process_file(included_file, output_file, current_file_dir, start_dir)
                else:
                    output_file.write(line)
            
            output_file.write(f"\n% --- End of content from {os.path.relpath(abs_path, start_dir)} ---\n\n")

    except FileNotFoundError:
        print(f"!! WARNING: File not found, skipping: {abs_path}", file=sys.stderr)
    except Exception as e:
        print(f"!! ERROR processing file {abs_path}: {e}", file=sys.stderr)


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python3 concat_latex.py <main_file.tex> <output_file.tex>")
        sys.exit(1)

    main_file = sys.argv[1]
    output_filename = sys.argv[2]
    # Make sure start_dir is the absolute path of the main file's directory
    start_dir = os.path.dirname(os.path.abspath(main_file))

    print(f"Starting concatenation from root file: {main_file}")
    print(f"Output will be written to: {output_filename}")

    with open(output_filename, 'w', encoding='utf-8') as f_out:
        f_out.write(f"% !!! THIS IS AN AUTO-GENERATED FILE !!!\n")
        f_out.write(f"% Generated from '{os.path.basename(main_file)}' by concat_latex.py\n")
        f_out.write(f"% Do not edit this file directly.\n\n")
        # Initial call, base_dir and start_dir are the same
        process_file(os.path.basename(main_file), f_out, start_dir, start_dir)

    print("\nConcatenation complete.")
    print(f"Final combined file created at: {output_filename}")

